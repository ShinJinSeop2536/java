컬렉션 프레임워크 
===============
1.컬렉션 프레임워크 소게 
----------------------

> 객체를 효율적으로 추가, 검색, 삭제 하는 간단한 벙법은 배열을 이용하는 것이다. 
> 하지만 배열을 생성할 때 경정되기 떄문에 불특정 다수의 객체를 저장하기에는 문제가 있다. 
> 또 다른 문제점은 객제를 삭제했을 떄 해당 인덱스가 비게 된다.
> 이런 문제점을 해결하고, 널리 알려져 있는 자료구조를 바탕으로 객체를 효율적으로 추가, 삭제, 검색할 수 있도록 패키지에 컬렉션 프레임워크를 포함시켜 놓았다.

> 컬렉션 프레임워크의 주요 인터페이스: List, Set, Map

*-List : ArrayList, Verctor,LinkedList*  
*-Set : HashSet, TreeSet*  
*-Map : HashMap, Hashtable, TreeMap, Properties*  

2.List 컬렉션
-------------

>list컬렉션은 객체를 일렬로 늘어놓은 구조를 가지고 있다. 자동 인덱스가 부여되고 인텍스로 객체를 검색, 삭제할 수 있는 기능을 제공한다.
>List는 객제 자체를 저장하는 것이 아니라 객체의 번지를 참조한다. null도 저장이 가능한데, 이 경우 해당 인덱스를 객체를 참조하지 않는다.
>List 인터페이스가 제네릭타입이기 때문에 국체적인 타입은 구현 객체를 생설할 떄 결정된다.

*추가 - add()*  
*검색 - get()*  
*삭제 - remove()*  

### 2.1 ArrayList  

>ArrayList에 객체를 추가하면 객체가 인댁스로 관리한다. 배열과 유사하지만 저장용량이 초과하면 저장용량이 늘어난다.
>ArrayList객체를 생성하면 내부에 10개의 객체를 저장할수 있는 초기 용량을 가지게 된다.
>ArrayList는 저장될때 Object 타입으로 변환되어 저장된다. 하지만 자바5부터 제네릭이 도입하여 타입을 지정해 불필요한 타입 변환을 하지 않도록 했다 .
>ArrayList는 0 이덱스부터 자례로 저잗되고, 객체를 제거하면 뒤 인덱서 부터 하나씩 당겨진다. 반대로 추가되면 하나씩 밀련난다. 
>빈번한 객체 삭제와 사입이 일어나는 곳에서는 사용하는것이 바람직 하지 않다.

### 2.2 Vector

>Vector는 ArrayList와 동일한 구조를 가진다.
>Vector는 동기화 메소드로 구성되어 있기 때문에 멀리 스레드가  동시에 이 메소드를 동시에 실행 할수 없다. 그래서 멀리 스레드 환경에서 안정하게 객체를 추가, 삭제할 수 있다.
>이것을 스레드가 안전하다라고 한다.

### 2.3 LinkedList

>ArrayList와 사용 방법은 똑같지만 내부 구조는 완전히 다르다. LinekList는 인접 참조를 링크해서 체인처럼 관리한다.
>LinkedList에서 특정 인덱스의 객체를 제거하면 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다. 특정 인덱스에 객체를 삽입할 때에도 마찬가지다.
>ArrayList는 끝에서 부터 추가/ 삭제는 하는 경우 빠르지만, 중간에 추가/삭제할 경우는 LinkedList가 빨르다.

3.Set 컬렉션
-------------

>List 컬렉션은 저장순서를 유지하지만, set 컬렉션은  저장 순서가 유지 되지 않는다. 객체를 중복해서 저장 할수 없고, 하나의 null만 저장할 수 있다.
>왜냐 하면 저장 할때의 순서와 나올때의 순서가 다를수 있다.

*-Set 종류 : HashSet, LinkedSet, TreeSet*  

>Set인터헤이스가 제네릭 타입이다.
>Set컬렉션은 반복해서 가져오는 반복자를 제공한다.

### 3.1 HashSet

>HashSet은 순선없이 저장하고 중복 저장하지 않는다.
>HashSet은 저장전 객체의 hashCode()메소드를 호출해서 해쉬코드를 얻어내고 비교한다. 다음에 다시 equals() 메소드로 객체를 비교하고 저장한다.
>문자열의 HashSet에 저장할경우 String클래스가 hashCode()와 equals()를 재정의 해서 저장한다.



